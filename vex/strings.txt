= Работа со строками =

== Обзор ==

VEX имеет строковый тип. Это полезно в некоторых случаях:

- Работа с текстом

- Использование в качестве имен файлов и `op` имен нод

- Работа с двоичными данными

== Строковые литералы ==

Строковые литералы могут быть заключены в одинарные кавычки (') или в двойные кавычки ("). Строки могут быть определены в виде неформатированных строк языка Python или C++.

{{{
#!vex
string s = 'foo';
string t = "bar";
string py = r"Hello world\n";	// в стиле Python, эквивалент "Hello world\\n"
string cpp = R"(Hello world\n)";   // в стиле C++, эквивалент "Hello world\\n"
}}}

В строках с экранированием (не неформатированные строки) известные экранированные последовательности автоматически преобразуются в их байтовое представление. Например, "\n" преобразуется в ASCII байт перевода на новую строку.

Неформатированные строки игнорируют экранированные последовательности. Для неформатированной строки "\n" будет интерпретироваться буквально как обратная косая черта и `n` в нижнем регистре.

Синтаксис строк можно совмещать
- Экранированные строки `"text"` или `'text'`
- Неформатированные строки в стиле Python `r"raw text"`
- Неформатированные строки в стиле C++ `R"delimiter(raw text)delimiter"`
    Где `delimiter` является необязательной строкой от 0 до 16 символов. В отличие от неформатированных строк в стиле Python, неформатированные строки в стиле C++ могут содержать многострочные текстовые и даже двоичные данные.

{{{
#!vex
string escaped = 'Line 1\nLine 2';
string raw = r"Line 1\nLine 1 continues";	// "Line 1\\nLine 1 continues"
string cppraw = R"(Line 1\nLine 1 continues)";	// "Line 1\\nLine 1 continues"
string cppmultiline = R"multi(This is a long
    string which has multiple lines.  The string
    also contains an embedded raw string R"(raw string)"
    But since the delimiter doesn't match, the string isn't
    actually ended until here.)multi";
}}}

== Объявление строковых типов ==

Общий вид для объявления строковой переменной `string  <<имя_переменной>>`:

{{{
#!vex
// Моя строка - обычная строка
string   mystring;
}}}

Чтобы объявить функцию, которая возвращает строку:

{{{
#!vex
// Функция, которая возвращает строку
string rgb_name()
{
...
};    
}}}

Используйте одинарные или двойные кавычки для указания массива букв.

{{{
#!vex
string a_string = "hello world!";
string another_string = 'good-bye!'
}}}

== Чтение и запись строковых значений ==

Используйте `string[<<индекс>>]` для чтения символа по его позиции в массиве.

Индекс представляет собой смещение в байтах, а не в символах. Это важное различие, когда вы имеете дело со строками в кодировке Unicode. VEX предполагает кодировку UTF-8 для всех строк. Если по заданному смещению не находится допустимый символ UTF-8, возвращается пустая строка. В противном случае возвращается полный символ UTF-8 - это может быть строка длиной больше единицы!

Границы строк проверяются во время выполнения. Результатом чтения за пределами границ является пустая строка. Чтение за пределами границ в будущем может привести к возникновению предупреждения или ошибки во время выполнения.

Используется индексирование в стиле языка Python. Это означает, что отрицательные индексы относятся к позициям с конца массива.

Обозначение срезов может использоваться в квадратных скобках для извлечения части строки. Это работает с последовательностями байтов, side stepping the UTF-8 requirements of the normal square bracket operation. Таким образом, если вы хотите третий байт, независимо от того, является ли он допустимым UTF-8 символом или нет, используйте:

{{{
#!vex
string a_string = "hello world!";
string thirdbyte = a_string[2:3];
}}}

Вы не можете присваивать значения массиву с помощью квадратных скобок.

(Функция [Vex:getcomp] эквивалентна использованию квадратных скобок.)

== Перебор элементов строки ==

Смотрите [Vex:foreach].

Обратите внимание, что вы получите пустые строки для позиций, которые не соответствуют действительным символам кодировки Unicode.

== Функции для работы со строками ==

Следующие функции позволяют управлять массивами.

[Vex:len]:
    Возвращает длину строки.

[Vex:append]:
    Добавляет другой массив в конец данного.

[Vex:ord]:
    Converts a UTF-8 string to a codepoint.

[Vex:chr]:
    Converts a codepoint to a UTF-8 string.

:bubble:
    #dir: right
    #display: gray
    [English version of this page|http://www.sidefx.com/docs/houdini16.5/vex/strings]
